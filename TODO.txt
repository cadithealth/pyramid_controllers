- consider using venusian for the decorators
  http://docs.pylonsproject.org/projects/venusian/en/latest/

- currently, given the following:
    class RootController(Controller):
      @expose
      def foo(self, request): return 'bar'
  a request to "/foo" will return "bar" (as expected). however
  "/foo/zig" does not yield a 404 as it should.

- do *extensible* request path translation, e.g.
    /foo/bar/file.ext becomes Class Root > Class Bar > method 'file_ext'
  or something like that...

- support @index(expose=True), which is equivalent to specifying
  both @index *and* @expose, ie. it makes the following method:
    @index(expose=True)
    def index(...): ...
  be accessible at both /path/ and /path/index.

- support @expose(methods=...) and @expose_defaults(methods=...) which
  limits what methods this function will support

- does pyramid_handlers not pollute the class namespace... how does
  it achieve that????
  the unit test from
    https://github.com/Pylons/pyramid_handlers/blob/master/pyramid_handlers/tests.py
  sort of implies that:
    def test_add_handler_doesnt_mutate_expose_dict(self):
        config = self._makeOne()
        views = []
        def dummy_add_view(**kw):
            views.append(kw)
        config.add_view = dummy_add_view
        exposed = [{'name':'^action3000$'}]
        class MyView(object):
            def action(self): # pragma: no cover
                return 'response'
            action.__exposed__ = exposed
        config.add_handler('name', '/{action}', MyView)
        self.assertEqual(exposed[0], {'name':'^action3000$'}) # not mutated

- perhaps change Controller.__init__(expose) to Controller.__init__(indirect)
  which is more in tune with how the rest of the framework interprets the
  attribute.

- add an `autoexpose` attribute to @expose_defaults

- create a command-line program that detects RootControllers and displays
  their hierarchy tree...

- implement a method name transformation logic. eg. if a request comes
  in for "such & such", then look up "such_and_such"... ok, that might
  be a bit too much, but perhaps something like 'such___such'?

- make `DescriberController.formattext_html` try to load docutils, and
  if successful, do rST formatting with that. otherwise fallback to the
  pseudo-stuff...

- currently the @lookup inspection done by the describer is a little
  'odd':

    class Foo(Controller):
      USER_ID = UserController(expose=False)
      @lookup
      def lookup(self, request, uid, ...):
        request.uid = uid
        return (self.USER_ID, ...)

  it should pull the info directly from the lookup, eg:

    uc = UserController()
    class Foo(Controller):
      @lookup
      def lookup(self, request, USER_ID, ...):
        request.uid = USER_ID
        return (uc, ...)

  in both cases, the resulting dpath will be '.../foo/{USER_ID}/...'
  **** the problem with this is: how does the framework then continue
  the inspection of UserController?...

- the unit test `test_expose_defaults_does_not_pollute` is currently
  disabled as it fails... fix it!

- REST controllers do not limit direct access (e.g. "PUT /object" and
  "GET /object/put") invoke the same handler... is that ok?

- REST controllers should allow easy method aliasing, eg:

  class C(RestController):
    @expose(name=('put', 'post'))
    def put(self, request):
      # ...

- when using @expose, @index or @default with the `method` parameter,
  the response is a '404 not found' if the method does not match. this
  should really be a '405 method not allowed' IFF all attributes
  match *except* method...

- update DescribeController to inspect decorator `method` parameters
