- enable a RestController method to NOT be listed as a verb, but
  instead as an endpoint... example:

    @expose()
    def search(self, request): pass

  gets listed as a method by pyramid-describe...
  perhaps:

    @expose(rest=False)

- it would be great if RestController automagically supported
  responses to the OPTIONS request...
  ==> see gripe about github in:
      http://docs.python-requests.org/en/latest/user/advanced/#http-verbs

- merge @default and @lookup: make the dispatcher look at the result -
  if it's a Response, assume @default behavior. otherwise, if it is a
  two-element tuple where the first parameter is a Controller, and the
  second parameter a list, assume @lookup behavior. then fallback to
  @default behavior, and assume that the returned data structure is
  intended for the renderer...

- RestController should use @lookup instead of @index...

- RestController should inspect all exposed methods, look at
  the "method" parameter, and use that. for example, these two
  should be equivalent:

    class C(RestController):
      @expose
      def put(self, request): return 'ok!'
      @expose
      def post(self, request): return self.put(request)

    class C(RestController):
      @expose(method=('put', 'post'))
      def put(self, request): return 'ok!'

- add support for OPTIONS request ==> should return which methods
  are supported for a given URL.

- if an @expose, @index, or @default limits the methods, and a request
  comes in for a different method which does not match, it should
  result in 405, not 404 (as it does currently). note that it should
  do this IFF all attributes match *except* method...

- what about supporting 'ext' with RestControllers...

- allow both 'method' and 'methods' parameter to @expose/@index/etc.

- consider using venusian for the decorators
  http://docs.pylonsproject.org/projects/venusian/en/latest/

- support @index(expose=True), which is equivalent to specifying
  both @index *and* @expose, ie. it makes the following method:
    @index(expose=True)
    def index(...): ...
  be accessible at both /path/ and /path/index.

- support @expose(method=...) and @expose_defaults(method=...) which
  limits what methods this function will support

- does pyramid_handlers not pollute the class namespace... how does
  it achieve that????
  the unit test from
    https://github.com/Pylons/pyramid_handlers/blob/master/pyramid_handlers/tests.py
  sort of implies that:
    def test_add_handler_doesnt_mutate_expose_dict(self):
        config = self._makeOne()
        views = []
        def dummy_add_view(**kw):
            views.append(kw)
        config.add_view = dummy_add_view
        exposed = [{'name':'^action3000$'}]
        class MyView(object):
            def action(self): # pragma: no cover
                return 'response'
            action.__exposed__ = exposed
        config.add_handler('name', '/{action}', MyView)
        self.assertEqual(exposed[0], {'name':'^action3000$'}) # not mutated

- perhaps change Controller.__init__(expose) to Controller.__init__(indirect)
  which is more in tune with how the rest of the framework interprets the
  attribute.

- add an `autoexpose` attribute to @expose_defaults

- create a command-line program that detects RootControllers and displays
  their hierarchy tree...

- implement a method name transformation logic. eg. if a request comes
  in for "such & such", then look up "such_and_such"... ok, that might
  be a bit too much, but perhaps something like 'such___such'?
  another example:
    /foo/bar/file.ext => Class Root > Class Bar > method 'file_ext'

- currently the @lookup inspection done by the describer is a little
  'odd':

    class Foo(Controller):
      USER_ID = UserController(expose=False)
      @lookup
      def lookup(self, request, uid, ...):
        request.uid = uid
        return (self.USER_ID, ...)

  it should pull the info directly from the lookup, eg:

    uc = UserController()
    class Foo(Controller):
      @lookup
      def lookup(self, request, USER_ID, ...):
        request.uid = USER_ID
        return (uc, ...)

  in both cases, the resulting dpath will be '.../foo/{USER_ID}/...'
  **** the problem with this is: how does the framework then continue
  the inspection of UserController?...

- the unit test `test_expose_defaults_does_not_pollute` is currently
  disabled as it fails... fix it!

- REST controllers do not limit direct access (e.g. "PUT /object" and
  "GET /object/put") invoke the same handler... is that ok?

- REST controllers should allow easy method aliasing, eg:

  class C(RestController):
    @expose(name=('put', 'post'))
    def put(self, request):
      # ...
